\documentclass{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\title{Конструирование компиляторов}
\author{affeeal}
\date{\today}

\begin{document}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{14 февраля 2024 г.}

\subsection{Дополнение к прошлой лекции}

Преимущества интерпретатора перед компилятором:

\begin{itemize}
  \item Выполнение "на ходу".
  \item Переносимость.
\end{itemize}

Преимущества комплятора перед интерпретатором:

\begin{itemize}
  \item Быстродействие.
  \item Проверка корректности программы на этапе компиляции.
\end{itemize}

\textbf{Примеры}. Java --- и компилируемый, и интерпретируемый ЯП. Так
обеспечивается и переносимость, и быстродействие. Порождение Python'ом
промежуточного byte-code'а.

\textit{JIT-компиляция} используется JVM, ADO.NET, Julia.

CISC, RISC --- обогащённые и сокращённые системы команд соответственно. ARM
реализует RISC в мобильных телефонах. RISC более передовой. См. микрокодовые
команды {$mu$-code).

\subsection{Фазы компиляции}

См. SSA-форма (static symbol assignment).

Сопрограммы в отличие от подпрограмм могут приостанавливать свою работу и
возвращаться с того же места.

\texttt{Примеры}. Go-рутины могут работать и как сопрограммы, и как потоки.
Операторы \texttt{yield} в Python и \texttt{yieldreturn} в C\# реализуют
сопрограммы.

\textit{Компоновка} --- построение готовой программы из раздельно
компилирующихся частей. Выполняется компоновщиом (linker, link editor,
"линковщик").

Компоновка бывает
\begin{itemize}
  \item Статической --- до запуска программы.

    \textbf{Пример}. Статическая компоновка для C/C++. На входе исходники на
      C/C++. Каждый из исходников обрабатывается препроцессором. Результат
      обрабатывается компилятором. Между препроцессором и компилятором
      промежуточных файлов, как правило, не создаётся. В Unix-подобных системах
      компилятор порождает ассемблерный листинг. Из ассемблера порождается
      объектный файл \texttt{.o}. С остальными файлами происходит то же самое.
      Далее включается компоновщик, получающий на входе объектные фалйы (а также
      библиотеки, традиционно \texttt{.a} в Unix-подобных системах). На выходе
      компоновщик порождает исполняемый файл с именем по умолчанию
      \texttt{a.out}.

      Библиотека \texttt{libm.a}, например, подключается опцией \texttt{-lm}.

      На Windows --- несколько исходников, препроцессор, компилятор. Компилятор
      сразу порождает объектный файл \texttt{.obj}. Библиотеки \texttt{.lib} (их
      тоже может быть несколько). Всё это падает на компоновщик, порождающий
      исполняемый файл (\texttt{.exe}). Т.е. нет фазы ассемблирования.

  \item Динамической --- во время выполнения программы.

    На входе исполняемый файл Unix или Windows, динамические библиотеки
    \texttt{.so}, (\texttt{.dll}). Загрузчик ОС создаёт пустое адресное
    пространство, загружает исполняемые файлы, ищет библиотеки, разрешает
    перекрёстные ссылки... В результате --- процесс в ОЗУ.

\end{itemize}

  Напомнить: библиотека поддержки во время исполнения (real-time support
  library).

\end{document}
