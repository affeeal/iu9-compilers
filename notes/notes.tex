\documentclass{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\title{Конструирование компиляторов}
\author{affeeal}
\date{\today}

\begin{document}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{14 февраля 2024 г.}

\subsection{Дополнение к прошлой лекции}

Преимущества интерпретатора перед компилятором:

\begin{itemize}
  \item Выполнение "на ходу".
  \item Переносимость.
\end{itemize}

Преимущества комплятора перед интерпретатором:

\begin{itemize}
  \item Быстродействие.
  \item Проверка корректности программы на этапе компиляции.
\end{itemize}

\textbf{Примеры}. Java --- и компилируемый, и интерпретируемый ЯП. Так
обеспечивается и переносимость, и быстродействие. Порождение Python'ом
промежуточного byte-code'а.

\textit{JIT-компиляция} используется JVM, ADO.NET, Julia.

CISC, RISC --- обогащённые и сокращённые системы команд соответственно. ARM
реализует RISC в мобильных телефонах. RISC более передовой. См. микрокодовые
команды {$mu$-code).

\subsection{Фазы компиляции}

См. SSA-форма (static symbol assignment).

Сопрограммы в отличие от подпрограмм могут приостанавливать свою работу и
возвращаться с того же места.

\texttt{Примеры}. Go-рутины могут работать и как сопрограммы, и как потоки.
Операторы \texttt{yield} в Python и \texttt{yieldreturn} в C\# реализуют
сопрограммы.

\textit{Компоновка} --- построение готовой программы из раздельно
компилирующихся частей. Выполняется компоновщиом (linker, link editor,
"линковщик").

Компоновка бывает
\begin{itemize}
  \item Статической --- до запуска программы.

    \textbf{Пример}. Статическая компоновка для C/C++. На входе исходники на
      C/C++. Каждый из исходников обрабатывается препроцессором. Результат
      обрабатывается компилятором. Между препроцессором и компилятором
      промежуточных файлов, как правило, не создаётся. В Unix-подобных системах
      компилятор порождает ассемблерный листинг. Из ассемблера порождается
      объектный файл \texttt{.o}. С остальными файлами происходит то же самое.
      Далее включается компоновщик, получающий на входе объектные фалйы (а также
      библиотеки, традиционно \texttt{.a} в Unix-подобных системах). На выходе
      компоновщик порождает исполняемый файл с именем по умолчанию
      \texttt{a.out}.

      Библиотека \texttt{libm.a}, например, подключается опцией \texttt{-lm}.

      На Windows --- несколько исходников, препроцессор, компилятор. Компилятор
      сразу порождает объектный файл \texttt{.obj}. Библиотеки \texttt{.lib} (их
      тоже может быть несколько). Всё это падает на компоновщик, порождающий
      исполняемый файл (\texttt{.exe}). Т.е. нет фазы ассемблирования.

  \item Динамической --- во время выполнения программы.

    На входе исполняемый файл Unix или Windows, динамические библиотеки
    \texttt{.so}, (\texttt{.dll}). Загрузчик ОС создаёт пустое адресное
    пространство, загружает исполняемые файлы, ищет библиотеки, разрешает
    перекрёстные ссылки... В результате --- процесс в ОЗУ.

\end{itemize}

\section{21 февраля 2024 г.}

Библиотека поддержки времени исполнения (runtime support library) - библиотека,
содержащая средства (как правило, подпрограммы и глобальные переменные, иногда
--- классы, типы данных), используемые в сгенерированном компилятором коде.
Туда входят средства управления памятью, сборщики мусора, исключения, примитивы
многопоточности, ввода-вывода.

Пример с обработкой исключений, \texttt{dynamic\_cast} в C++. Нет чёткого
разделения между стандартной библиотекой и RSL.

См. экстракоды.

\section{Рекурсивный спуск}

Если $PARSE(R_1|R_2)$, и, например, $\varepsilon \in FIRST(R_1)$,
$\varepsilon \notin FIRST(R_2)$, то сначала проверяем принадлежность
$FIRST(R_2)$.

\section{Вопросы к экзамену}

\begin{itemize}
  \item Что надо убрать из правил РБНФ, чтобы они описывали регулярный язык?
  Нетерминалы.

  \item Почему процесс получения FIRST-множества рано или поздно
  останавливается? Мы только добавляем, множество терминалов ограничено. На
  каждом шаге множество растёт. Бесконечно множество расти не может.

  \item Как алгоритм Эрли отвечает проблеме синтаксического анализа? См. 
  лекция 4, стр. 56. Аксиому можно вывести за 1 и более шагов. Если в исходной
  строке сработал Completer, строка является раскрытием нетерминала, для
  которого сработал Completer.
\end{itemize}

\end{document}
